<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>machine burning</title><link href="http://hitnail.net/" rel="alternate"></link><link href="http://hitnail.net/feeds/gsoc2013.atom.xml" rel="self"></link><id>http://hitnail.net/</id><updated>2013-09-09T00:00:00-03:00</updated><entry><title>Elixir: Debugging and Inspection - weeks 11 and 12</title><link href="http://hitnail.net/elixir-debugging-and-inspection-weeks-11-and-12.html" rel="alternate"></link><updated>2013-09-09T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-09-09:elixir-debugging-and-inspection-weeks-11-and-12.html</id><summary type="html">&lt;p&gt;The two final productive weeks of Debugging and Inspection on Summer of Code have been quite busy.
I've done a lot of refactoring on IEx code and added shiny new features to showcase
the power of the debugging infrastructure being developed.&lt;/p&gt;
&lt;h3&gt;Server-Evaluator-Reader&lt;/h3&gt;
&lt;p&gt;IEx, as of today, works using two processes: a Reader and a Server. 
The first waits for user input on &lt;code&gt;stdin&lt;/code&gt;, while the latter evaluates code and controls
the session. That way, evaluating code on IEx results on busy waiting: the Reader has 
to wait for an evaluation to finish before getting more input.&lt;/p&gt;
&lt;p&gt;Clearly, for a debugging environment, that's not the optimal behaviour. It's expected that
a debugger is able to get input from the user &lt;strong&gt;during&lt;/strong&gt; any code evaluation. 
&lt;code&gt;Server&lt;/code&gt; was refactored into an &lt;code&gt;Evaluator&lt;/code&gt;/&lt;code&gt;Server&lt;/code&gt; structure, and now we are ready to handle
those asynchronous debug events while evaluating anything.&lt;/p&gt;
&lt;h3&gt;Debug helpers&lt;/h3&gt;
&lt;p&gt;Finally some features! The current functionality embedded into the debugger is made available 
through IEx helpers. A list of the available helpers on the shell is printed using the &lt;code&gt;h&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;The first helper introduced is the debug-compile helper &lt;code&gt;dc/2&lt;/code&gt;. Its interface is the same as the
&lt;code&gt;c/2&lt;/code&gt; helper, accepting a filename or a list of filenames as parameter. The files will be compiled with
debugging directives and a list of contained modules will be returned.&lt;/p&gt;
&lt;p&gt;Other two helpers provide pattern-based tracing, &lt;code&gt;dpg/0&lt;/code&gt; and &lt;code&gt;dps/1&lt;/code&gt; (debug-pattern-get/set).
The usage is simple: set a list of patterns for matching the source code being run and get debugger
ouput when it runs.
As patterns are matched &lt;strong&gt;after&lt;/strong&gt; sub-expressions are expanded, this tool can be very flexible, as shown
by running our &lt;code&gt;sum.exs&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;defmodule Sum do
  def list(x // [1,2,3]) do
    Enum.reduce x, 0, fn
      (1, x) -&amp;gt; 1 + x
      (a, b) -&amp;gt; a + b 
    end
  end
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We get the following session:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Regex-based tracing" src="img/sumlist-dc-dpg-dps.png" /&gt;&lt;/p&gt;
&lt;p&gt;Currently it uses regular expressions over the output of &lt;code&gt;Macro.to_string&lt;/code&gt; on code tuples. 
Jos√© suggested a really cool feature using runtime tuple pattern-matching, yet to be done.
Another nice addition coming soon is be the breakpoint shell, which will allow running arbitrary 
code that changes process state on breakpoints.&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - weeks 9 and 10</title><link href="http://hitnail.net/elixir-debugging-and-inspection-weeks-9-and-10.html" rel="alternate"></link><updated>2013-08-26T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-08-26:elixir-debugging-and-inspection-weeks-9-and-10.html</id><summary type="html">&lt;p&gt;After last weeks' drama about anonymous functions, we could say that everything went well: the final
code wouldn't differ much from the current &lt;code&gt;defdebug&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; expressions.
On weeks 9 and 10 I've finally managed to write code to make all runtime tests pass, dealt with with 
non-debugged code interoperability, did some module name refactoring and rambled bit about a simple CLI.&lt;/p&gt;
&lt;h3&gt;Mystery on PIDland&lt;/h3&gt;
&lt;p&gt;The trouble of nested eval calls must have caused me some kind of &lt;strong&gt;evalception&lt;/strong&gt; trauma.
This last test related to the last features I've had implemented showed that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;defdebug msg_f2 do
  pid &lt;span class="o"&gt;=&lt;/span&gt; spawn fn &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
    receive do
      &lt;span class="p"&gt;{&lt;/span&gt; from&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;msg &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        from &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;ack
    end
  end
  pid &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; self&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;msg &lt;span class="p"&gt;}&lt;/span&gt;
  receive do
    &lt;span class="o"&gt;:&lt;/span&gt;ack &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;ok
  end
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Running this piece of code would either result in a perfect &lt;code&gt;:ok&lt;/code&gt; or on a process hanging on a &lt;code&gt;receive&lt;/code&gt;
expression with an &lt;code&gt;:EXIT&lt;/code&gt; message from a process with an unknown PID. Deeply disturbing.
Inspecting stuff on that code revealed another problem: the escaping functions wouldn't
iterate deeply on data structures, so that &lt;code&gt;{ self, :msg }&lt;/code&gt; wouldn't get escaped properly, and that
&lt;code&gt;self&lt;/code&gt; PID would never get matched on receive. Bingo!&lt;/p&gt;
&lt;h3&gt;Escape to the hills&lt;/h3&gt;
&lt;p&gt;On the beginning of the project I thought that escaping was the lesser of my concerns. 
That, however, proved to be wrong, as PIDs and then anonymous functions can't be injected inside an Elixir
quoted syntax tree.
My first solution, always escaping the result of evaluated code, seemed to be definitive until interoperability
with non-debugged code became a concern.
One solution was obvious at this point: evaluated values should always be the same as the results yielded from
a non-debugging run, so escaping should be done before evaluating!&lt;/p&gt;
&lt;p&gt;At that point, &lt;code&gt;Runner.eval_quoted&lt;/code&gt; had some code extracted that became &lt;code&gt;Runner.escape_and_eval&lt;/code&gt;.
Some function calls were changed, as not every eval call on the runtime would require escaping.
For my surprise, after solving the escaping related problems, that message passing test passed and we got
0 failures (:&lt;/p&gt;
&lt;h3&gt;Major Tom to Ground Control&lt;/h3&gt;
&lt;p&gt;The design of a CLI involved creating a &lt;code&gt;Controller&lt;/code&gt; module that will interact with &lt;code&gt;Runner&lt;/code&gt;, giving
the heads up for process execution.
But what about our good old &lt;code&gt;Controller&lt;/code&gt; module, that only serves to the purpose of keeping the 
state of a process? Well, guess what, it is now called &lt;code&gt;StateServer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The CLI is very simple: when a &lt;code&gt;Controller&lt;/code&gt; process gets notified by a running process that
an expression is about to be executed, an IO loop starts and a command is read. 
The running process has to wait for authorization before continuing, that way we will be able to
implement more advanced stepping and breakpoints by tweaking the protocol between those processes.&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - weeks 7 and 8</title><link href="http://hitnail.net/elixir-debugging-and-inspection-weeks-7-and-8.html" rel="alternate"></link><updated>2013-08-12T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-08-12:elixir-debugging-and-inspection-weeks-7-and-8.html</id><summary type="html">&lt;p&gt;The second half of the GSoC program started with the Elixir debugger beginning to show some stability.
Some of the challenges foreseen when taking the decision on the metaprogramming-based design have been solved,
but other tricky control-flow structures involving exception handling and multiprocessing now have to be tackled.&lt;/p&gt;
&lt;h3&gt;Rescue catching or keep trying&lt;/h3&gt;
&lt;p&gt;Exceptions require a lot of caution on their handling: the debugger should isolate its own exceptions from
those raised withing the interpreted program.
With that goal in mind some refactoring work was needed to tag and enclose the &lt;code&gt;:elixir.eval_quoted&lt;/code&gt; calls
on a rescue-all block.&lt;/p&gt;
&lt;p&gt;The expression building trick used to emulate variable initialization used for case expressions
showed itself an amazing tool for implementing many constructs of Elixir on the debugger runtime.
However, this pattern couldn't be used for matching variables on rescue/catch clauses, as, differently
from case clauses, the names defined inside exception-handling blocks don't persist on the rest of the
program.&lt;/p&gt;
&lt;p&gt;An example illustrates better this behaviour:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def foo do
  try do
    raise &amp;quot;message&amp;quot;
  rescue
    x in [RuntimeError] -&amp;gt;
      x.message # =&amp;gt; &amp;quot;message&amp;quot;
  end
  x  # =&amp;gt; ERROR: x not alive here
end

def bar do
  case &amp;quot;message&amp;quot; do
    x -&amp;gt; x # =&amp;gt; &amp;quot;message&amp;quot;
  end
  x  # =&amp;gt; x is alive here, equals to &amp;quot;message&amp;quot;)
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To avoid implementing the semantics for rescue/catch, we resorted to the before dreaded nested eval calls.
That strategy worked pretty well with some rough edges yet to be rounded, mainly coming from this &lt;strong&gt;evalception&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Private mode&lt;/h3&gt;
&lt;p&gt;I have foreseen anonymous functions somehow as bump on the road while nested eval calls were ruled out of the options.
After the change on the structure of Evaluators/Coordinators/Runners, that approach became again the perfect fit
for implementing &lt;code&gt;fn -&amp;gt; (...) end&lt;/code&gt; constructs.&lt;/p&gt;
&lt;p&gt;The next weeks will host a lot of effort on anonymous functions and polishing try/rescue/catch expressions,
and hopefully the first version of the debugger shell.&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - weeks 5 and 6</title><link href="http://hitnail.net/elixir-debugging-and-inspection-weeks-5-and-6.html" rel="alternate"></link><updated>2013-07-29T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-07-29:elixir-debugging-and-inspection-weeks-5-and-6.html</id><summary type="html">&lt;p&gt;The last two weeks have been quite busy Elixir debugging: the project has seen a fair amount of changes 
on the design side and many practical issues came up. 
All that had to do with implementing debugging of programs using multi-processing directives, 
which are the most important and distinctive features of Elixir.&lt;/p&gt;
&lt;h3&gt;Evaluators, Coordinators and Runners&lt;/h3&gt;
&lt;p&gt;On our previous design, an &lt;code&gt;Evaluator&lt;/code&gt; would responsible for keeping the state of a current process and evaluate code on its behalf.
That idea worked quite well when not dealing with message sending for one basic reason: with code actually running on another process,
the PID (process identifier) and the mailbox being used for message passing wouldn't be that of the process being evaluated.
On that context, switching from &lt;strong&gt;interpreted&lt;/strong&gt; to &lt;strong&gt;native&lt;/strong&gt; running modes would be very tricky, as all PIDs would have to be translated
from host to Evaluator and vice-versa.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Coordinator&lt;/code&gt;/&lt;code&gt;Runner&lt;/code&gt; structure would fit much better the problem: the first process would be the bridge between the user interface
and the running code, keeping the state of the code evaluation for the possiblity of inspection; 
the latter would evaluate it's own expressions while waiting for the approval of its &lt;code&gt;Coordinator&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Such a pid thing to do&lt;/h3&gt;
&lt;p&gt;A practical problem faced recently was injecting PID literals on an Elixir tree -- there's no thing such as PID literals.
The approach used by the interpreter being implemented is to depth-first search on the quoted expressions and backtrack
the values of sub-expressions by replacing them on the tree with the result of their evaluations.
So, when the value of an expression is a process identifier, &lt;code&gt;:elixir.eval_quoted&lt;/code&gt; would return something that looks like
&lt;code&gt;#PID&amp;lt;0.27.0&amp;gt;&lt;/code&gt;, which is clearly not valid Elixir syntax and would yield the infamous &lt;code&gt;invalid quoted expression: #PID&amp;lt;0.27.0&amp;gt;&lt;/code&gt;
when interpreted.&lt;/p&gt;
&lt;p&gt;The solution to that problem would require a bit of name mangling and corner case handling.
PIDs have to be provided to the binding just after they're evaluated, as there's no literal representation for them&lt;sup&gt;1&lt;/sup&gt;, so
with some name mangling we generate a very distinctive variable name for a process identifier and filter everything coming
off our slick &lt;code&gt;:elixir_code.eval_quoted&lt;/code&gt; calls.
In the end, turning &lt;code&gt;#PID&amp;lt;0.27.0&amp;gt;&lt;/code&gt; into a variable called &lt;code&gt;__PID_0_27_0__&lt;/code&gt; bound to the PID's value (and not a representation) pretty
much solves the problem.&lt;/p&gt;
&lt;p&gt;&lt;sub&gt;&lt;sup&gt;1&lt;/sup&gt;well, as a matter of fact one could use a char list as a PID literal using the &lt;code&gt;list_to_pid/1&lt;/code&gt; and &lt;code&gt;pid_to_list/1&lt;/code&gt; functions,
but that'd just make things get more complex.&lt;/sub&gt;&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - week 4</title><link href="http://hitnail.net/elixir-debugging-and-inspection-week-4.html" rel="alternate"></link><updated>2013-07-14T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-07-14:elixir-debugging-and-inspection-week-4.html</id><summary type="html">&lt;p&gt;This week all the last pretty printing issue was solved, thanks to a pretty cool solution proposed by
Jos√© (my mentor on the project). 
More details about the solution, based on changing a bit the way the algorithm decides between formatting
a document on &lt;code&gt;:flat&lt;/code&gt; or &lt;code&gt;:break&lt;/code&gt; mode, are available on the 
&lt;a href="https://github.com/elixir-lang/elixir/commit/2dc1e41aca4b456ee7644f3c4c97a2205f0df36b"&gt;commit that closed the issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some advance was made regarding the design of the debugger and how to achieve the desired functionalities.
My initial idea was to implement an Elixir interpreter based on quoted expressions, and then insert debugging functionalities
on top of that runtime, similar to the way OTP's &lt;a href="http://www.erlang.org/doc/apps/debugger/debugger_chapter.html"&gt;debugger&lt;/a&gt; is built.
That approach would enable total control over code execution and provide a sandboxed environment for debugging.
However, emulating Elixir's semantics would require a large amount of effort that could be avoided with a design based on meta-programming.&lt;/p&gt;
&lt;p&gt;The idea of using meta-programming to solve the problem is to inject message passing calls to &lt;em&gt;Evaluators&lt;/em&gt;, processes spawned to 
handle function calls for modules running on &lt;em&gt;debug&lt;/em&gt; mode, on the programs to be debugged.
That way, &lt;em&gt;Evaluators&lt;/em&gt; can access the current running scope and are able to provide inspecting information and manipulate
the control flow as requested by the debugger interface.&lt;/p&gt;
&lt;p&gt;As a starting point to that approach, I'm implementing a proof of concept that provides a &lt;code&gt;defdebug&lt;/code&gt; macro, which allows stepping
the execution of the defined function.&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - week 3</title><link href="http://hitnail.net/elixir-debugging-and-inspection-week-3.html" rel="alternate"></link><updated>2013-07-08T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-07-08:elixir-debugging-and-inspection-week-3.html</id><summary type="html">&lt;p&gt;The third week of my GSoC project featured the &lt;a href="https://github.com/elixir-lang/elixir/pull/1377"&gt;pretty printer&lt;/a&gt; being merged into upstream.
This is quite exciting for me, as it's my first expressive contribution to an open source project (:&lt;/p&gt;
&lt;p&gt;An &lt;a href="https://github.com/elixir-lang/elixir/issues/1383"&gt;issue&lt;/a&gt; was raised on the behavior of the pretty printer when printing lists.
This kind of output is expected from the Wadler pretty printing algorithm, as it can seen on the Ruby implementation as well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;irb(main):001:0&amp;gt; require &amp;#39;pp&amp;#39;
=&amp;gt; true
irb(main):002:0&amp;gt; pp (1..100).to_a
[1,
 2,
 3,
 4,
 5,
 6,
 7,
 8,
 9,
 10,
# ...and so on
 90,
 91,
 92,
 93,
 94,
 95,
 96,
 97,
 98,
 99,
 100]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Hughes algorithm implementation present on OTP, despite less performant, allows that kind of fluid paragraph-like 
documents to be produced.
I'm still trying to think of any way of tweaking the Wadler algorithm to solve the issue.&lt;/p&gt;
&lt;p&gt;This week I also started making my way through OTP's &lt;code&gt;dbg&lt;/code&gt; source code and trying out some Erlang debugging tools. 
Maybe one of these days a quick survey about those tools will pop up here on the blog. &lt;/p&gt;
&lt;p&gt;Oh, and I survived finals week and will hand over my last college assignments today, which means full-time Elixir'ing
on the weeks to come!&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - week 2</title><link href="http://hitnail.net/elixir-debugging-and-inspection-week-2.html" rel="alternate"></link><updated>2013-07-01T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-07-01:elixir-debugging-and-inspection-week-2.html</id><summary type="html">&lt;p&gt;Not much going on this week on my GSoC project, mainly due to the finals season on my university. Besides studying to exams my class assignments kept me busy with &lt;a href="https://gist.github.com/brunoro/5894145"&gt;cryptography-related&lt;/a&gt; &lt;a href="https://gist.github.com/brunoro/5893701"&gt;algorithms&lt;/a&gt;, &lt;a href="https://bitbucket.org/brunoro/aes-webcl"&gt;AES on WebCL&lt;/a&gt; and &lt;a href="https://bitbucket.org/brunoro/clone-constant-args"&gt;LLVM passes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="&amp;quot;Brace yourselves, finals are coming&amp;quot;" src="http://farm3.staticflickr.com/2681/4407477295_c124d447fb.jpg" title="Finals, serious business." /&gt;&lt;/p&gt;
&lt;p&gt;I started adjusting the code on the pretty-printer pull request to use the new defrecordp syntax on Elixir. Also, there's some documentation pending on the public interface of the Binary.Inspect.Utils functions&lt;/p&gt;
&lt;p&gt;My goal is to have the code merged on upstream until the end of the week, so I can start working on ANSI colors on the pretty-printer and crafting some inspeaction helpers for iex.&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Elixir: Debugging and Inspection - week 1</title><link href="http://hitnail.net/elixir-debugging-and-inspection-week-1.html" rel="alternate"></link><updated>2013-06-23T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-06-23:elixir-debugging-and-inspection-week-1.html</id><summary type="html">&lt;p&gt;Today was over the first week of development of Summer of Code, and I worked mostly getting pretty-printing on Elixir. 
There was already a &lt;a href="https://github.com/elixir-lang/elixir/pull/1047"&gt;pull request&lt;/a&gt; implementing the algorithm proposed 
by &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.635"&gt;Wadler (2003)&lt;/a&gt;, but some performance issues still needed
to be taken care of before merging it to upstream.&lt;/p&gt;
&lt;p&gt;After reading the &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200"&gt;Lindig (2000)&lt;/a&gt; paper on the exponential behaviour 
of the Wadler pretty printer on strict languages, I figured it could be the main issue, as the original implementation relies on Haskell's lazy evaluation.
I adapted the &lt;code&gt;wadler.ex&lt;/code&gt; module from the pull request to follow the OCaml implementation proposed by Lindig. 
As those tweaks didn't bring any performance gains, I moved on profiling the code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="&amp;quot;First attempt at optimizing the pretty-printer&amp;quot;" src="img/gsoc-week1-small.png" title="Oops, no performance gains with Lindig approach." /&gt;&lt;/p&gt;
&lt;p&gt;Profiling showed that the exponential behaviour on the code arouse from the usage of the string concatenation operator in Elixir, 
which has performance linear on length of the left-hand string. Therefore, I patched both pretty printing implementations (Wadler's and Lindig's) 
to build lists of strings and make a one single &lt;code&gt;List.join&lt;/code&gt; call at the end of the process. Those changes made the pretty printer show the expected 
linear behaviour, and the strict implementation showed better performance than the one original lazy one.&lt;/p&gt;
&lt;p&gt;&lt;img alt="&amp;quot;String concatenation was the problem&amp;quot;" src="img/gsoc-week1-big.png" title="Linear at last, removing string concatenation." /&gt;&lt;/p&gt;
&lt;p&gt;Some optimizations followed: @devinus pointed out that using &lt;code&gt;iolist_to_binary&lt;/code&gt; would bring even more performance gains over &lt;code&gt;List.join&lt;/code&gt;, 
and that using &lt;code&gt;List.duplicate&lt;/code&gt; over &lt;code&gt;String.duplicate&lt;/code&gt; to generate indent strings would also make the pretty printer faster. 
I benchmarked the suggestions, and indeed the version using &lt;code&gt;iolist_to_binary&lt;/code&gt; got better results. &lt;/p&gt;
&lt;p&gt;&lt;img alt="&amp;quot;iolist_to_binary over List.join&amp;quot;" src="img/gsoc-week1-join.png" title="String list joining: serious business" /&gt;&lt;/p&gt;
&lt;p&gt;However, a strange fact came up measuring &lt;code&gt;List.duplicate&lt;/code&gt; vs &lt;code&gt;String.duplicate&lt;/code&gt;: the usage List.duplicate brought back the exponential 
performance to the function. Profiling showed that the &lt;code&gt;List.duplicate&lt;/code&gt; version ended up making a massive amount of &lt;code&gt;:lists.duplicate/3&lt;/code&gt; calls; 
to check that, I changed the &lt;code&gt;List.duplicate&lt;/code&gt; call to an equivalent &lt;code&gt;:lists.duplicate/2&lt;/code&gt; call, and the number of &lt;code&gt;:lists.duplicate/3&lt;/code&gt; got back to normal! 
@josevalim pointed that we should keep the &lt;code&gt;:lists.duplicate/2&lt;/code&gt; version of the code and further investigate the behaviour or List.duplicate afterwards.&lt;/p&gt;
&lt;p&gt;&lt;img alt="&amp;quot;strange List.duplicate behaviour&amp;quot;" src="img/gsoc-week1-dup.png" title="List.duplicate just calls :lists.duplicate. Oh, wait..." /&gt;&lt;/p&gt;
&lt;p&gt;The regression tests for the new implmentation were getting stuck on some Mix tests, which were caused by inspect calls relying on unformatted string results. 
I've added the pretty: false option to all the Kernel.inspect calls on Mix, but the tests still failed. After that, I've verified that the &lt;code&gt;pretty: false&lt;/code&gt; 
option had to be reimplemented, which resulted on adding a corner case to the &lt;code&gt;Wadler.fits?&lt;/code&gt; and &lt;code&gt;Wadler.format&lt;/code&gt; methods to handle lines with "infinite width", 
disabling any formatting done by the pretty printer.&lt;/p&gt;
&lt;p&gt;There are still two pending issues to merge the pretty printer on upstream:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making the records used on wadler.ex private. I'm still wondering about the best way to handle the typespecs with defrecordp, which doesn't generate types.&lt;/li&gt;
&lt;li&gt;Documenting the Binary.Inspect.Util module, which contain functions that'll be made public, allowing custom pretty printers to be written.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The benchmark code I used is available &lt;a href="https://gist.github.com/brunoro/5786164"&gt;here&lt;/a&gt;.&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry><entry><title>Debugging and Inspecting Elixir on Summer of Code 2013!</title><link href="http://hitnail.net/debugging-and-inspecting-elixir-on-summer-of-code-2013.html" rel="alternate"></link><updated>2013-05-27T00:00:00-03:00</updated><author><name>gus</name></author><id>tag:hitnail.net,2013-05-27:debugging-and-inspecting-elixir-on-summer-of-code-2013.html</id><summary type="html">&lt;p&gt;Just a really quick update with great news: the project I pitched to &lt;a href="http://beamcommunity.github.com/"&gt;BEAM Community&lt;/a&gt; 
was accepcted on &lt;a href="google-melange.com/gsoc/homepage/google/gsoc2013"&gt;Google Summer of Code 2013&lt;/a&gt;! 
This means that until 15 September I'll be quite busy developing code inspection tools and a basic 
CLI debugger functionality for the great &lt;a href="http://www.elixir-lang.org"&gt;Elixir&lt;/a&gt; language.&lt;/p&gt;
&lt;p&gt;Also, this blog see some love at least for the next weeks, as I'll post weekly reports on the state of the project here (:&lt;/p&gt;</summary><category term="gsoc2013"></category><category term="elixir"></category></entry></feed>